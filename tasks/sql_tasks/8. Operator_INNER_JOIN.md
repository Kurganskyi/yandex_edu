# Задания по оператору INNER JOIN

## Задание 1

Нужно объединить данные двух таблиц: `track` со всеми треками в магазине и `invoice_line` с купленными треками.

Выгрузите таблицу с названием трека и числом, которое соответствует тому, сколько раз трек покупали. Учитывайте, что в одном заказе один и тот же трек может встречаться несколько раз. Если какой-либо из треков не покупали или о купленном треке нет информации — такие записи не должны войти в таблицу. Оставьте только уникальные значения с помощью группировки и отберите первые 20 записей.

### Решение

```sql
SELECT 
    t.name AS track_name,
    SUM(il.quantity) AS purchase_count
FROM 
    track t
INNER JOIN 
    invoice_line il ON t.track_id = il.track_id
GROUP BY 
    t.track_id, t.name
ORDER BY 
    purchase_count DESC
LIMIT 20;
```

---

## Задание 2

Нужно дополнить запрос: добавьте поле с идентификатором плейлиста `playlist_id`. Такое поле можно получить из таблицы `playlist_track`. В этой таблице собраны идентификаторы плейлистов и треков (поле `track_id`). Условие остаётся прежним: если идентификаторы треков не совпадают во всех трёх таблицах, такие треки не должны войти в итоговую таблицу. Выведите первые 20 записей.

### Решение

```sql
SELECT 
    t.name AS track_name,
    SUM(il.quantity) AS purchase_count,
    pt.playlist_id
FROM 
    track t
INNER JOIN 
    invoice_line il ON t.track_id = il.track_id
INNER JOIN 
    playlist_track pt ON t.track_id = pt.track_id
GROUP BY 
    t.track_id, t.name, pt.playlist_id
ORDER BY 
    purchase_count DESC, pt.playlist_id
LIMIT 20;
```

---

## Задание 3

Идентификатор плейлиста теперь указан в итоговой таблице. Но что это за плейлисты — непонятно. Эту информацию можно взять в четвёртой таблице — `playlist`. Таблица содержит поле `playlist_id` с идентификатором плейлиста и поле `name` — с его названием. Добавьте в итоговую таблицу поле `name`. Условия те же: данные без совпадения не должны попасть в таблицу. Ограничьте вывод первыми 20 записями. Чтобы тренажер корректно отобразил поле с названием треков и поле с названием плейлистов, необходимо дать им разные псевдонимы. При этом псевдонимы могут быть любыми, главное, чтобы они были разными.

### Решение

```sql
SELECT 
    t.name AS track_name,
    SUM(il.quantity) AS purchase_count,
    pt.playlist_id,
    p.name AS playlist_name
FROM 
    track t
INNER JOIN 
    invoice_line il ON t.track_id = il.track_id
INNER JOIN 
    playlist_track pt ON t.track_id = pt.track_id
INNER JOIN 
    playlist p ON pt.playlist_id = p.playlist_id
GROUP BY 
    t.track_id, t.name, pt.playlist_id, p.name
ORDER BY 
    purchase_count DESC, pt.playlist_id
LIMIT 20;
```

---

## Задание 4

Теперь проанализируйте получившуюся таблицу. Нужно посчитать суммарную стоимость треков для каждого плейлиста. Отобразите в таблице два поля: `playlist_name` с названием плейлиста и `total_revenue` с суммарной стоимостью. Отсортируйте данные по значению в поле `total_revenue` от большего к меньшему.

### Решение

```sql
SELECT 
    p.name AS playlist_name,
    SUM(t.unit_price) AS total_revenue
FROM 
    playlist p
INNER JOIN 
    playlist_track pt ON p.playlist_id = pt.playlist_id
INNER JOIN 
    track t ON pt.track_id = t.track_id
GROUP BY 
    p.playlist_id, p.name
ORDER BY 
    total_revenue DESC;
```

---

## Задание 5

Массовую любовь к музыке 90-х можно понять. А как обстоит дело с жанрами — какие популярнее? Сгруппируйте данные по жанрам и посчитайте количество заказов. Выведите на экран два поля: одно с названием жанра, второе — с количеством купленных треков этого жанра. Отсортируйте таблицу по убыванию количества заказов.

### Решение

```sql
SELECT 
    g.name AS genre_name,
    SUM(il.quantity) AS total_purchased_tracks
FROM 
    genre g
INNER JOIN 
    track t ON g.genre_id = t.genre_id
INNER JOIN 
    invoice_line il ON t.track_id = il.track_id
GROUP BY 
    g.genre_id, g.name
ORDER BY 
    total_purchased_tracks DESC;
```

---

## Задание 6

Отберите названия уникальных категорий фильмов, в которых снималась Ума Вуд (англ. Uma Wood).

### Решение

```sql
SELECT DISTINCT 
    c.name AS category_name
FROM 
    actor a
INNER JOIN 
    film_actor fa ON a.actor_id = fa.actor_id
INNER JOIN 
    film_category fc ON fa.film_id = fc.film_id
INNER JOIN 
    category c ON fc.category_id = c.category_id
WHERE 
    a.first_name = 'Uma' 
    AND a.last_name = 'Wood';
```
