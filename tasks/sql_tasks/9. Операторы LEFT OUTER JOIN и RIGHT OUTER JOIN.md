# Задания по операторам LEFT OUTER JOIN и RIGHT OUTER JOIN

## Задание 1

Выведите названия всех треков, добавив информацию о датах, в которые эти треки покупали. Ни один трек не должен потеряться, даже если его не покупали вообще. Чтобы получить нужный результат, надо соединить три таблицы сразу, ведь таблица `invoice`, которая хранит данные о дате заказа, не содержит информации о купленных треках.

Сначала соедините таблицы `track` и `invoice_line` по ключу `track_id`, а затем присоедините таблицу `invoice` по ключу `invoice_id`. В итоговую таблицу поместите два поля: `name` из таблицы `track` и `invoice_date` из таблицы `invoice`. Приведите столбец с датами к типу `date`.

### Решение

```sql
SELECT
    t.name AS track_name,
    CAST(i.invoice_date AS DATE) AS invoice_date
FROM
    track AS t
LEFT JOIN
    invoice_line AS il ON t.track_id = il.track_id
LEFT JOIN
    invoice AS i ON il.invoice_id = i.invoice_id;
```

---

## Задание 2

Для каждого года, выраженного числом, посчитайте уникальные названия купленных треков.

### Решение

```sql
SELECT
    EXTRACT(YEAR FROM i.invoice_date)::INT AS year,
    COUNT(DISTINCT t.name) AS unique_track_names
FROM
    invoice_line AS il
INNER JOIN
    invoice AS i ON il.invoice_id = i.invoice_id
INNER JOIN
    track AS t ON il.track_id = t.track_id
GROUP BY
    EXTRACT(YEAR FROM i.invoice_date)
ORDER BY
    year;
```

---

## Задание 3

Выгрузите таблицу из двух полей: первое поле с фамилией сотрудника, второе — с количеством пользователей, чьи запросы этот сотрудник обработал. Назовите поля employee_last_name и all_customers соответственно. Сгруппируйте записи по идентификатору сотрудника (лучше так, чем по фамилии, чтобы избежать неточностей). Отсортируйте количество пользователей по убыванию, а фамилии сотрудников — в лексикографическом порядке.

### Решение

```sql
SELECT
    s.last_name AS employee_last_name,
    COUNT(DISTINCT c.customer_id) AS all_customers
FROM
    staff AS s
LEFT JOIN
    client AS c ON s.employee_id = c.support_rep_id
GROUP BY
    s.employee_id, s.last_name
ORDER BY
    all_customers DESC, employee_last_name ASC;
```
---

## Задание 4

У некоторых сотрудников есть менеджеры — их идентификаторы указаны в поле reports_to. Посмотрите внимательно на схему базы: таблица staff отсылает сама к себе. Это нормально, можно не создавать новую таблицу с менеджерами. 

Теперь можно разобраться в иерархии команды. Отобразите таблицу с двумя полями: в первое поле войдут фамилии всех сотрудников, а во второе — фамилии их менеджеров. Назовите поля employee_last_name и manager_last_name.

### Решение

```sql
SELECT
    e.last_name AS employee_last_name,
    m.last_name AS manager_last_name
FROM
    staff AS e
LEFT JOIN
    staff AS m ON e.reports_to = m.employee_id;
```

---

## Задание 5

Отобразите названия фильмов, в которых снимались актёры, не указанные в базе.

### Решение

```sql
SELECT DISTINCT
    m.title
FROM
    film_actor AS fa
LEFT JOIN
    actor AS a ON fa.actor_id = a.actor_id
INNER JOIN
    movie AS m ON fa.film_id = m.film_id
WHERE
    a.actor_id IS NULL;
```